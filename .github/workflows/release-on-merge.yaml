## This action is run when a commit is made to a `release-*` branch (ideally from patch-* PR)
##  - Creates Github Release (with codebase after commit) and Git Tag
##  - Creates Changelog for Release
##  - Upmerges branch to develop (so any changes that were made in release branch are in develop)

name: "Release-Merge"

on: 
  push:
    branches:
      - release-*

jobs:
  create-release-tag:
    strategy: 
      max-parallel: 1
    runs-on: ubuntu-latest

    outputs:
      major: ${{ steps.version.outputs.major }}
      minor: ${{ steps.version.outputs.minor }}
      patch: ${{ steps.version.outputs.patch }}
      merged: ${{ steps.check_release.outputs.merged }}
      release-commit: ${{ steps.check_release.outputs.release-commit }}
      main-commit: ${{ steps.check_release.outputs.main-commit }}

    steps: 
    - uses: actions/checkout@v2
      with:
        ## This is a Personal Access Token from Admin User that allows us to bypass branch protections on develop
        token: ${{ secrets.PAT }}
        fetch-depth: 0

    # NOTE: Update CHANGELOG_PREFIX_LIST to configure the lines you wan to include in the changelog (body of release PR)
    - name: "Get Release Info"
      id: version
      run: |
        git fetch --all --tags;
        git checkout ${GITHUB_REF##*/};
        cd scripts/release;
        unzip git-mkver-linux.zip;
        cd ../..;
        echo "##[set-output name=major;]$(./scripts/release/git-mkver-linux next --format '{Major}')";
        echo "##[set-output name=minor;]$(./scripts/release/git-mkver-linux next --format '{Minor}')";
        echo "##[set-output name=patch;]$(./scripts/release/git-mkver-linux next --format '{Patch}')";
        CHANGELOG=$(git log --format=%s $(git describe --tags --abbrev=0)..HEAD | grep -i -E "^($CHANGELOG_PREFIX_LIST)" | sed "s/^/ - /") 
        CHANGELOG="${CHANGELOG//'%'/'%25'}"
        CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
        CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
        echo "##[set-output name=changelog;]$(echo $CHANGELOG)";
      env:
        CHANGELOG_PREFIX_LIST: "feature|feat|fix|bugfix|bug"

    # Find info about `release-*` branch:
    # 1. has the release branch already been merged to `main` branch 
    # 2. commit hashes of `main` branch and `release-*` branch
    - name: Check Create Release
      id: check_release
      run: |
        echo "##[set-output name=merged;]$(git log main | grep -E $RELEASE_PATCH
        echo "##[set-output name=main-commit;]$(git log --oneline main | awk '{if (NR == 1) commit=$1 } END { print commit }')";
        echo "##[set-output name=release-commit;]$(git log --oneline ${GITHUB_REF##*/} | awk '{if (NR == 1) commit=$1 } END { print commit }')";
      env:
        RELEASE_PATCH: (release-${{ steps.version.outputs.major }}\.${{ steps.version.outputs.minor }}\.${{ steps.version.outputs.patch }}|patch-${{ steps.version.outputs.major }}\.${{ steps.version.outputs.minor }})

    # Create Github Release:
    # if it has been merged to `main` before (not first cut)
    # AND if `release-*` branch commit does not match `main` (not a fast forward)
    - name: Create Github Release
      id: create_release
      uses: actions/create-release@v1
      if: steps.check_release.outputs.merged != '' && steps.check_release.outputs.release-commit != steps.check_release.outputs.main-commit
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.version.outputs.major }}.${{ steps.version.outputs.minor }}.${{ steps.version.outputs.patch }}
        release_name: release-${{ steps.version.outputs.major }}.${{ steps.version.outputs.minor }}.${{ steps.version.outputs.patch }}
        body: ${{ steps.version.outputs.changelog }}
  
  upmerge-after-release:      
    strategy: 
      max-parallel: 1
    runs-on: ubuntu-latest
    needs: create-release-tag

    steps: 
    - uses: actions/checkout@v2
      with:
        ## This is a Personal Access Token from Admin User that allows us to bypass branch protections on develop
        token: ${{ secrets.PAT }}
        fetch-depth: 0  

    # Upmerge `release-*` branch to `develop` when:
    # it has been merged to `main` before (not first cut)
    # AND `release-*` branch is not same commit as `main` (not a fast forward)
    - name: Upmerge develop After Release
      if: needs.create-release-tag.outputs.merged != '' && needs.create-release-tag.outputs.release-commit != needs.create-release-tag.outputs.main-commit
      run: |
        git config --global user.name 'Release Cut';
        git config --global user.email 'release@cut.com';
        ./scripts/release/release-prep-upmerge.sh ${GITHUB_REF##*/}
        git commit -m "upmerge after $RELEASE";
        git push;
      env:
        RELEASE: v${{ needs.create-release-tag.outputs.major }}.${{ needs.create-release-tag.outputs.minor }}.${{ needs.create-release-tag.outputs.patch }}

    # Upmerge `release-*` branch to `main` when:
    # it has been merged to `main` before (not first cut)
    # AND `release-*` branch is not same commit as `main` (not a fast forward)
    - name: Upmerge main After Release
      if: needs.create-release-tag.outputs.merged != '' && needs.create-release-tag.outputs.release-commit != needs.create-release-tag.outputs.main-commit
      run: |
        git config --global user.name 'Release Cut';
        git config --global user.email 'release@cut.com';
        git checkout main;
        git pull;
        git merge ${GITHUB_REF##*/};
        git commit -m "upmerge after $RELEASE";
        git push;
      env:
        RELEASE: v${{ needs.create-release-tag.outputs.major }}.${{ needs.create-release-tag.outputs.minor }}.${{ needs.create-release-tag.outputs.patch }}